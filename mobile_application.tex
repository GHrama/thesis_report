\chapter{Explanation of the Mobile Application}

\section{The Building Blocks}

The following sections will explain integral parts of the server and client part of the mobile application. A gist of the architecture is shown
in figure \ref{fig:bb}. As it can be seen, the mobile app represents the user participating in the experiment. As the experiment goes on,
mobile sensor data and responses to the data requests which are collected are periodically sent to the Kinvey Data Store. 
The users can choose to login into the FairDataShare Portal from their computer or the mobile app. Once the user is authenticated, the user request
is sent from the FairDataShare server to the Kinvey Data Store. Kinvey in turn fetches the appropriate data and gives it to the FairDataShare Server. This in turn structures the data so it can be easily readable, and pushes it to the user to see on the portal. The concept is similar for the Stakeholders, except they can only access the portal through the computer and not the mobile app.

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio]{./images/blocks_app}
\caption{Conceptual Diagram of Mobile Application Architecture}
\label{fig:bb}
\end{figure}

\section{The Mobile Application}

\subsection{Local Storage} \label{loc}
The local storage is an integral part of the application. The database used is SQLite and is the default database
for the Android environment. Small sized unrelated data is stored in preferences files, whereas larger related
data is stored in the database. The following paragraphs will explain each database present in this application followed with 
their function. All tables explained here are pertaining to the user using the mobile application.

\begin{figure}[htp]
\subtop[Table Schema of QUESTIONSTORE\label{fig:db_quest}]{\includegraphics[width=0.4\linewidth]{./images/db_quest}}\hspace{1em}
\subtop[Table Schema of WHICHANSWERS\label{fig:db_which}]{\includegraphics[width=0.4\linewidth]{./images/db_which_1}}
\caption{Table Schemas}
\label{fig:ts1}
\end{figure}


Figure \ref{fig:db_quest} shows the QUESTIONSTORE's table schema. This table stores each possible data request with its sensor $SENSOR$, stakeholder  $STAKEHOLDER$ and context $CONTEXT$. Each of these are represented by an integer, for example sensor 0 stands for Accelerometer sensor. Each data request is accompanied by
an unique question identifier $QID$, weight assigned $WEIGHT$ and the cost $COST$. This data is not sent to 
the server.

Figure \ref{fig:db_which} depicts the table WHICHANSWERS's table schema. This stores the questions identifier $QID$ of each data request that has
been answered by the user for each round. This is helpful while fetching data requests, so as not to fetch the request twice in the same round. This makes sure that all questions are answered before answering them for a second time. This data is not sent to the server.

\begin{figure}[htp]
\subtop[Table Schema of STOREANSWERS\label{fig:db_ans}]{\includegraphics[width=0.4\linewidth]{./images/db_ans}} \hspace{1em}
\subtop[Table Schema of STOREPOINTS\label{fig:db_points}]{\includegraphics[width=0.4\linewidth]{./images/db_points}}
\caption{Table Schemas}
\label{fig:ts11}
\end{figure}

Figure \ref{fig:db_ans} explains the schema of STOREANSWERS table. This table is used to store the data request identifier $QID$ with the corresponding
user responses $LEVEL$, along with the increase or decrease in credit obtained $COST_OBT$. The total cost can be calculated by adding all the costs in this table. Similarly, the total privacy can be calculated by averaging all the user responses in this table. Only the most recent responses are stored in this table. This content is not sent over to the server.

Figure \ref{fig:db_points} denotes the schema of STOREPOINTS table. This table is used to store the credit and privacy obtained for each bidding day.
This information is sent to the server as soon one bidding day is over.

\begin{figure}[ht!]
\centering
\includegraphics[width=0.4\linewidth]{./images/db_ur}
\caption{Table USERRESPONSECACHE Schema}
\label{fig:db_ur}
\end{figure}

Figure \ref{fig:db_ur} depicts the USERRESPONSECACHE tables's schema. This table stores a unique key $KEY$ for each user response, followed by a flag $ISSENT$, which is 1 if the response is not sent to the server, and 0 if it is sent. The user response saved consists of the following entries :

\begin{enumerate}
	\item User Id
	\item Timestamp of response
    \item Sensor Id
    \item Stakeholder Id
    \item Context Id
    \item Privacy Level answered for this data request
    \item Cost obtained for this data request
    \item Current Total Privacy of user
    \item Current Total Credit of user
    \item Maximum Obtainable Credit for this data request in this round
    \item Metric Chosen to Improve  (Improve Privacy or Improve Credit)
\end{enumerate}

All of the above fields are packed into the field $ur$ shown in \ref{fig:db_ur}. The data in this table is sent to the server. Once the entry is sent to the server, the $ISSENT$ field is changed to 0 and deleted locally. The unique keys $KEY$ are useful for deleting sent entries.

Figure \ref{fig:ts2} and \ref{fig:ts22} show the table schemas for data storage of the following sensors:

\begin{enumerate}
	\item Accelerometer in the STOREACCELEROMETER table
	\item Noise in the STORENOISE
    \item Location in the  STORELOCATION
    \item Light in the  STORELIGHT
\end{enumerate}

\begin{figure}[htp]
\subtop[Table Schema of STOREACCELEROMETER\label{fig:db_acc}]{\includegraphics[width=0.4\linewidth]{./images/db_acc}}\hspace{1em}
\subtop[Table Schema of STORENOISE \label{fig:db_noise}]{\includegraphics[width=0.4\linewidth]{./images/db_noise}}%
\caption{Table Schemas for Sensor Data}
\label{fig:ts2}
\end{figure}

The general schema for all the sensors is the following :

\begin{enumerate}
	\item $KEY$ - Uniquely identifies each sensor entry
	\item $TIMESTAMP$ - The time the sensor value was collected
    \item $ISSENT$ - Denotes whether the sensor entry has been sent to the server or not
    \item The other columns are specific to each sensor and represent the actual sensor values of the user collected
\end{enumerate}

\begin{figure}[htp]
\subtop[Table Schema of STORELOCATION\label{fig:db_loc}]{\includegraphics[width=0.4\linewidth]{./images/db_loc}}\hspace{1em}
\subtop[Table Schema of STORELIGHT \label{fig:db_light}]{\includegraphics[width=0.4\linewidth]{./images/db_light}}%
\caption{Table Schemas for Sensor Data}
\label{fig:ts22}
\end{figure}


\subsection{Alarms and Notifications}

Every bidding day where the user can answer data requests lasts for a period of 24 hours. After one bidding day is over, the system needs to be informed in a timely to perform some application critical functions. The function performed are explained in detail in section \ref{next}. 
To inform the system of such an event Android provides the functionality in the form of alarms. 

Alarms can be set to go off just once or in a repeated fashion to trigger tasks. Unfortunately, the alarms provided by Android are not exact for some versions, in the sense that they are triggered around that time set but not exactly to optimize the battery. Hence, we decided to set the repeating alarms manually. 

The first time the alarm is set to ring in exactly 24 hours, but things change when the phone is switched off.
One of the conditions of the experiment is not to have the phone switched off at any time. Neverthless, we take into account the scenario where
the phone is kept switched off for a period of time. There are various things that can happen:

\begin{enumerate}
	\item The phone is rebooted.
	\item The phone is switched off, during this time an alarm is missed.
    \item The phone is switched off for a period greater than 24 hours. One or more alarms can be missed.
\end{enumerate}

Once the phone is switched off, all alarms are erased. Alarms do not execute when the phone is switched off. Hence, when the phone switches on,
BootReceiver service of the application is triggered with pseudocode \ref{boot}.

\begin{algorithm}
\caption{BootService Algorithm}\label{boot}
\begin{algorithmic}[1]
\Procedure{BootService}{}
\State $\textit{now} \gets \text{current timestamp}$
\State $i \gets \text{timestamp of last triggered alarm}$
\If {$\textit{now}-i < 86400$}
  \State $\text{Call }\textit{SetAlarmLater()}$
\Else
  \State $\text{Set alarm in 200 seconds}$
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

This checks whether an alarm has been missed, if it has 200 seconds is given for the phone to stabilize before triggering it. Otherwise, a new alarm is set using pseudocode \ref{setalarm}. To set an alarm we need the time difference between now and when the alarm should ring. After that is calculated, the alarm is set.

\begin{algorithm}
\caption{Alarm Algorithm}\label{setalarm}
\begin{algorithmic}[1]
\Procedure{SetAlarmLater}{}
\State $\textit{now} \gets \text{current timestamp}$
\State $i \gets \text{timestamp of last triggered alarm}$
\State $\textit{latertime} \gets \textit{i}+\text{86400}$
\State $\textit{latergap} \gets \textit{latertime}-\textit{now}$
\State $\text{Set Alarm in latergap seconds}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Going to the Next Data Sharing Day} \label{next}
Once the alarm rings, it marks the end of a bidding day. Once a bidding day ends a number of tasks need to be executed
and for this the NextDayService is triggered, which is described in pseudocode \ref{nextday}. To start with the the privacy and credit is sent to
the sent to the server and stored locally in the STOREPOINTS table. $Privacy$ which is the total privacy obtained, $Credit$ is the total credit obtained, $Round$ which is the number of time the user answered all the questions and $CurrentQuestion$ which is the current question the user is answering is all reset to zero. The $Day$ corresponds to the current day number is incremented by one to denote the next bidding day.

\begin{algorithm}
\caption{NextDayService Algorithm}\label{nextday}
\begin{algorithmic}[1]
\Procedure{NextDayService}{}
\State $\text{Store }\textit{Privacy, Credit, Day } \text{in } \textit{STOREPOINTS}$
\State $\text{Send }\textit{Privacy, Credit, Day } \text{to Server}$
\State $\textit{Privacy, Credit, Round, CurrentQuestion} \gets \text{0}$
\State $\textit{Day} \gets \textit{Day}+1$
\State $\text{Store current time}$
\State $\text{Call }\textit{Summarization()}$
\If {$\textit{Day} > \textit{End}$}
  \State $\text{End experiment}$
\Else
  \State $\text{Update user interface elements}$ 
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

The current time of executing the alarm is saved in case the phone is rebooted or switched off. After that, the sensor data which is saved locally
needs to be summarized, the corresponding method is called and is explained in pseudocode \ref{sum}. Finally we need to check if the experiment is over or not and update the user interface accordingly. This means either we update the various metrics on the improvement and bidding screens, or we 
show the end of experiment screen.

\subsection{Fetching Data Requests}
A data request needs to be fetched in two scenarios :

\begin{enumerate}
	\item After a question has been answered in the first bidding day.
	\item After the privacy or credit improvement button has been clicked.
\end{enumerate}

In the first bidding day, once a data request has been answered the next one is fetched sequentially from the database. This just requires knowing the current data request number and fetching the next data request from table QUESTIONSTORE. 

For the other bidding days, fetching of the data requests depends on the improvement button chosen. According to the choice, the following is done:

\begin{enumerate}
	\item Improve Privacy - Obtain question from table STOREANSWERS where user has answered with lowest privacy
	\item Improve Credit - Obtain question from table STOREANSWERS where user has answered with highest privacy
\end{enumerate}

In addition to sending the data request to the user interface, we need to show how choosing each option of the data request will affect the total privacy and total credit metrics. To do this for the total cost, we output $last-possible$, where $last$ stands for the credit obtained the last time the data request was answered. $possible$ stands for the maximum amount of credit that can be obtained for this option (each data request has five privacy options). The possible total cost changes are shown under the options. For more detail on how credits are split among options in a data request refer \ref{}.

Each option of a data request has an associated percentage of data that is given away as described in \ref{}. According to the percentage of data given away, the total privacy is calculated for each possible option. The difference between the current privacy and each possible total privacy is calculated and indicated under each option. This gives an indication to the user as to what each option will do to the metrics.

\subsection{Recording User Choices}

\ref{fig:db_ur} describes the table USERRESPONSECACHE. Each time a user enters a response to a data request, all the fields mentioned in section
\ref{loc} are recorded and store in a class object. This object is transformed into a byte array so as to be stored easily in the table as is.
When the JobNetworkService described in \ref{job} is called, the class object is sent as is to the server.


\subsection{Sensor Data Collection and Summarization} 

Sensor data is collected from the following sensors :

\begin{enumerate}
	\item Accelerometer sensor
	\item Noise sensor
    \item Location sensor
    \item Light sensor
\end{enumerate}

A sensor service is triggered when the application is installed and is stopped when the experiment is over. This collects data from every sensor
every 30 seconds and stores it in the appropriate tables mentioned in section \ref{loc}.
At the end of a bidding day, sensor data needs to be summarized according to the wishes of the user. This starts by first finding out the lowest privacy level for each sensor. Privacy levels range from one to five, that is from the lowest to highest privacy levels. Using this level
summarization is done as shown in pseudocode \ref{sum}. Each privacy level corresponds to an action:

\begin{enumerate}
	\item 1- All data is sent to the server
	\item 2- Send 75\% of the data
    \item 3- Send 50\% of the data
    \item 4- Send 25\% of the data
    \item 5- Do not send any data
\end{enumerate}

Initially all the sensor data has a field $ISSENT$ with value of zero. Data that should be sent to the server is set with $ISSENT=1$, and all that have value $ISSENT=0$ are ignored.

\begin{algorithm}
\caption{Summarization Algorithm}\label{sum}
\begin{algorithmic}[1]
\Procedure{Summarization}{}
\For{$\text{each sensor}$}
\State $\text{Fetch sensor data from } \textit{sensor table}$
\State $\textit{level} \gets \text{Fetch user privacy level}$
\If {$\textit{level} \gets 1$}
  \State $\text{Set all } \textit{ISSENT} \gets \text{1}$
\ElsIf {$\textit{level} \gets 2$}
	\For{$\text{3 out of every 4 records}$}
 	 \State $\textit{ISSENT} \gets \text{1}$
 	\EndFor 
\ElsIf {$\textit{level} \gets 3$}
  \For{$\text{1 out of every 2 records}$}
 	 \State $\textit{ISSENT} \gets \text{1}$
 	\EndFor
\ElsIf {$\textit{level} \gets 4$}
  \For{$\text{1 out of every 4 records}$}
 	 \State $\textit{ISSENT} \gets \text{1}$
 	\EndFor
\EndIf
\State $\text{Delete all entries with } \textit{ISSENT} \gets 0$
\State $\text{Update Database}$
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Server Synchronization} \label{job}

User responses and sensor data need to be sent to the server. This is done periodically every 5000 seconds in order to free up space on the phone when the internet is available. This is triggered first when the application is started. Data is fetched from the tables in the database. Data with fields marked as $ISSENT=1$ is data that is ready and that has not been sent yet to the server. Such data is sent, and when an acknowledgement is received, this data is deleted from the table.

\begin{algorithm}
\caption{JobNetworkService Algorithm}\label{nextday}
\begin{algorithmic}[1]
\Procedure{NetworkService}{}
\State $ \text{Fecth data from } \textit{USERRESPONSECACHE}$
 \For{$\text{each record}$}
 	 \If {$\textit{ISSENT} == \textit{1}$}
  \State $\text{Send record to Server}$
  \If {$\text{SUCCESS}$}
  \State $\text{Delete record}$  
  \EndIf
  \EndIf
 	\EndFor

\For{$\text{each sensor}$}
 	 \State $ \text{Fecth data from } \textit{sensor table}$
 	  \For{$\text{each record}$}
 	 \If {$\textit{ISSENT} == \textit{1}$}
  \State $\text{Send record to Server}$
  \If {$\text{SUCCESS}$}
  \State $\text{Delete record}$  
  \EndIf
  \EndIf
 	\EndFor
	
 	\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}



\section{The Server}

\subsection{Kinvey Data Storage}

Kinvey \footnote{\url{http://kinvey.com/}} is a mobile backend as a service which provides a platform for mobile phones to link applications to a backend cloud storage. For the purpose of this application the backend has been used to store data for some business logic implementations.
\subsubsection{Security}
All communication from the application to the server is encrypted using TLS/SSL encryption \footnote{Kinvey white paper : KINVEY CLOUD
SERVICE: SECURITY
OVERVIEW 2014}to communicate with the backend service. This is automatically provided by the Kinvey SDK.

\subsubsection{Collection Store}

Locally, all information is store in SQLite which is a relational database. The database used in Kinvey is MongoDB so instead we have collections 
on the server.
When the user starts the application, general personal information is entered as explained in \ref{}. This data is stored in the
collection UserInformation with the schema shown in the screen shots \ref{fig:col_ui_1} and \ref{fig:col_ui_2}.

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_ui_1}
\caption{Screenshot of Collection UserInformation Part 1}
\label{fig:col_ui_1}
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_ui_2}
\caption{Screenshot of Collection UserInformation Part 2}
\label{fig:col_ui_2}
\end{figure}

Once this is done, users have to categorize the various Features, Sensors, Stakeholders and then the various Contexts. This information is sent to the server in collections named Features, Sensors, Stakeholders and Contexts. This is shown in \ref{fig:col_f}, \ref{fig:col_s}, \ref{fig:col_ss} and \ref{fig:col_c} respectively.

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_feature_cat}
\caption{Screenshot of Collection Features}
\label{fig:col_f}
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_sensors_cat}
\caption{Screenshot of Collection Sensors}
\label{fig:col_s}
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_dc_cat}
\caption{Screenshot of Collection Stakeholders}
\label{fig:col_ss}
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_context_cat}
\caption{Screenshot of Collection Contexts}
\label{fig:col_c}
\end{figure}

All the data stored locally on the mobile phone which is sent by the JobNetworkService explained in section \ref{job} is received by Kinvey.
User responses are store in collection USERRESPONSE shown in \ref{fig:col_ur_1} and \ref{fig:col_ur_2}.


\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio, height=0.6\textwidth]{./images/collection_ur_1}
\caption{Screenshot of Collection UserResponse Part 1}
\label{fig:col_ur_1}
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_ur_2}
\caption{Screenshot of Collection UserResponse Part 2}
\label{fig:col_ur_2}
\end{figure}

The sensor data sent by the JobNetworkService is stored in collections named after the sensors themselves. The schema of the tables
is shown in figures \ref{fig:col_loc}, \ref{fig:col_acc}, \ref{fig:col_light} and \ref{fig:col_noise}.

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_loc}
\caption{Screenshot of Collection Location}
\label{fig:col_loc}
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_acc}
\caption{Screenshot of Collection Accelerometer}
\label{fig:col_acc}
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_noise}
\caption{Screenshot of Collection Noise}
\label{fig:col_noise}
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_light}
\caption{Screenshot of Collection Light}
\label{fig:col_light}
\end{figure}

To keep track of all the existing users in the experiment, the collection Users stores all unique user identification strings.
This is shown in \ref{fig:col_users}.

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_users}
\caption{Screenshot of Collection Users}
\label{fig:col_users}
\end{figure}

Finally, the collection Score shown in \ref{fig:col_score} stores the total privacy, total credit obtained by the user for each bidding day.

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth,keepaspectratio,height=0.6\textwidth]{./images/collection_score}
\caption{Screenshot of Collection Score}
\label{fig:col_score}
\end{figure}


\subsubsection{Bussiness Logic} \ref{bl}
Most of the bussiness logic used for the FairDataShare portal is present on Kinvey. There are two main scripts stored in Kinvey:
\begin{enumerate}
    \item Script to find the privacy preference
    \item Script for summarization
\end{enumerate}

The stakeholder make a request for data giving the following details:
\begin{enumerate}
    \item Bidding day number
    \item Anonymous user
    \item Sensor
    \item Context
\end{enumerate}

Given this input plus the category of the stakeholder, we look into the UserResponse Collection trying to find the most recent record that
fit this criteria and extract the records privacy level.

Once we know the privacy level, summarization can be done. Data has been taken from the user with a certain summarization, and if the summarization level is lower than the privacy level extracted, further summarization needs to be done. The pseudocode is shown in \ref{sum1}.

\begin{algorithm}
\caption{Server Summarization Algorithm}\label{sum1}
\begin{algorithmic}[1]
\Procedure{Summarization}{}
\State $\textit{data} \gets \text{sensor data from collection}$
\If {$\textit{summarizationlevel} == \textit{privacylevel}$}
	\State $\textbf{Return }\textit{data}$
\Else
	\State $\textit{skip} \gets \textit{summarizationlevel}-\textit{privacylevel}+1$
	 \For{$\text{every }\textit{skip} \text{number records out of 4}$}
 	 \State $\text{Delete record from}\textit{ data}$
 	 \EndFor
\EndIf
\State $\text{Return data to portal}$
\EndProcedure
\end{algorithmic}
\end{algorithm}



\subsection{FairDataShare Web Portal}
The FairDataShare portal makes use of a server at ETH Zurich other Kinvey to safely store the usernames, passwords of users and the stakeholders in a collection. The database technology used is MongoDB. The language used to interact with Kinvey is Express.js, which is based on Node.js. Most of the data portal business logic is on Kinvey described in section \ref{bl}. The webpage was constructed using Html and css. All screenshots of the portal including detailed information is provided in chapter \ref{exp}.









